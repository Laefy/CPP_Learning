<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gestion m√©moire on Cours de C&#43;&#43; - Niveau Master</title>
    <link>https://laefy.github.io/CPP_Learning/chapter3/</link>
    <description>Recent content in Gestion m√©moire on Cours de C&#43;&#43; - Niveau Master</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://laefy.github.io/CPP_Learning/chapter3/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Dur√©e de vie</title>
      <link>https://laefy.github.io/CPP_Learning/chapter3/1-lifespan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://laefy.github.io/CPP_Learning/chapter3/1-lifespan/</guid>
      <description>Port√©e d&amp;rsquo;une variable locale Afin de parler de dur√©e de vie, nous allons commencer par parler de la port√©e de nos variables. Comme vous le savez peut-√™tre, la port√©e d&amp;rsquo;une variable d√©finit la portion de code dans laquelle le compilateur nous permet de l&amp;rsquo;utiliser.
Si on d√©finit une variable dans une fonction, la port√©e de celle-ci d√©marre √† sa d√©finition et se termine √† la fin du bloc dans lequel celle-ci a √©t√© d√©finie.</description>
    </item>
    
    <item>
      <title>Ownership</title>
      <link>https://laefy.github.io/CPP_Learning/chapter3/2-ownership/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://laefy.github.io/CPP_Learning/chapter3/2-ownership/</guid>
      <description>Ownership On dit qu&amp;rsquo;un objet A est le propri√©taire, ou le owner, d&amp;rsquo;un objet B lorsque la destruction de A entra√Æne la destruction de B.
Dans l&amp;rsquo;exercice pr√©c√©dent, on peut donc dire que box √©tait propri√©taire de box._content.
Consid√©rons un autre exemple :
std::vector&amp;lt;Box&amp;gt; boxes; boxes.emplace_back(&amp;#34;gift1&amp;#34;); Box&amp;amp; gift2 = boxes.emplace_back(&amp;#34;gift2&amp;#34;); Box gift3 = boxes.emplace_back(&amp;#34;gift3&amp;#34;); Ici, le tableau boxes est le propri√©taire des objets boxes[0], boxes[1] et boxes[2]. Il est √©galement propri√©taire de l&amp;rsquo;objet gift2, puisqu&amp;rsquo;il s&amp;rsquo;agit d&amp;rsquo;une r√©f√©rence sur boxes[1].</description>
    </item>
    
    <item>
      <title>Allocation dynamique</title>
      <link>https://laefy.github.io/CPP_Learning/chapter3/3-allocation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://laefy.github.io/CPP_Learning/chapter3/3-allocation/</guid>
      <description>Nous allons maintenant voir comment il est possible d&amp;rsquo;allouer de la m√©moire simplement, en particulier sans avoir √† se soucier des fuites m√©moire.
 Allocation d&amp;rsquo;une primitive Pour cr√©er un objet sur le tas, nous allons nous servir d&amp;rsquo;un petit utilitaire appel√© std::unique_ptr et de la fonction std::make_unique. Ces deux symboles se trouvent dans le header &amp;lt;memory&amp;gt;.
Voici la syntaxe permettant d&amp;rsquo;allouer de la m√©moire pour un entier :
#include &amp;lt;iostream&amp;gt;#include &amp;lt;memory&amp;gt; void fcn() { std::unique_ptr&amp;lt;int&amp;gt; int_on_heap = std::make_unique&amp;lt;int&amp;gt;(3); std::cout &amp;lt;&amp;lt; *int_on_heap &amp;lt;&amp;lt; std::endl; // affiche 3  *int_on_heap = 5; std::cout &amp;lt;&amp;lt; *int_on_heap &amp;lt;&amp;lt; std::endl; // affiche 5 } La classe unique_ptr est donc un symbole que l&amp;rsquo;on template par le type qu&amp;rsquo;il doit contenir.</description>
    </item>
    
    <item>
      <title>D√©placement</title>
      <link>https://laefy.github.io/CPP_Learning/chapter3/4-move-sem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://laefy.github.io/CPP_Learning/chapter3/4-move-sem/</guid>
      <description>Nous avons vu pr√©c√©dement que les unique_ptr ne pouvaient pas √™tre copi√©s. Cependant, le vector a r√©ussi √† provoquer leur &amp;ldquo;d√©placement&amp;rdquo; en m√©moire pour effectuer sa r√©allocation.
Nous allons voir comment faire de m√™me afin de pouvoir manipuler les unique_ptr avec un peu plus de souplesse.
 Construction sur place Lorsqu&amp;rsquo;une fonction retourne un objet et que celui-ci est utilis√© pour initialiser une variable, aucune copie n&amp;rsquo;a lieu. L&amp;rsquo;objet est directement construit √† l&amp;rsquo;adresse m√©moire qui lui √©tait r√©serv√©e dans le code appelant.</description>
    </item>
    
    <item>
      <title>Questionnaire !</title>
      <link>https://laefy.github.io/CPP_Learning/chapter3/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://laefy.github.io/CPP_Learning/chapter3/test/</guid>
      <description>C&amp;rsquo;est l&amp;rsquo;heure du test ! Bon courage üôÇ
 Vous √™tes : Votre adresse mail : Votre groupe : Initiaux 1Initiaux 2Alternants 1Alternants 21- Comment d√©finir la p√©riode de validit√© d‚Äôun objet ?

2- Citez une bonne raison d‚Äôallouer de la m√©moire via un unique_ptr plut√¥t que via un pointeur simple (avec new).

3- Quelle fonction de la librarie standard permet de transf√©rer le contenu d‚Äôun objet dans un autre ?</description>
    </item>
    
    <item>
      <title>Synth√®se</title>
      <link>https://laefy.github.io/CPP_Learning/chapter3/summary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://laefy.github.io/CPP_Learning/chapter3/summary/</guid>
      <description>Ce qu&amp;rsquo;il faut retenir Th√©orie  La dur√©e de vie d&amp;rsquo;un objet s&amp;rsquo;√©tend de sa construction √† sa destruction. Lorsque la dur√©e de vie d&amp;rsquo;un objet s&amp;rsquo;ach√®ve, il n&amp;rsquo;est plus valide de l&amp;rsquo;utiliser. La port√©e d&amp;rsquo;une r√©f√©rence peut exc√©der la dur√©e de vie de l&amp;rsquo;objet r√©f√©renc√© (=&amp;gt; dangling reference). Un objet A est propri√©taire d&amp;rsquo;un objet B si la destruction de A entra√Æne celle de B. Aucune copie n&amp;rsquo;est faite lorsqu&amp;rsquo;on initialise une variable avec la valeur de retour d&amp;rsquo;une fonction (mandatory copy-elision)  Pratique  Un unique_ptr n&amp;rsquo;est pas copiable.</description>
    </item>
    
    <item>
      <title>Merci !</title>
      <link>https://laefy.github.io/CPP_Learning/chapter3/test_done/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://laefy.github.io/CPP_Learning/chapter3/test_done/</guid>
      <description>Vos r√©ponses nous ont bien √©t√© communiqu√©es üòÉ Retourner √† la synth√®se du Chapitre</description>
    </item>
    
  </channel>
</rss>
